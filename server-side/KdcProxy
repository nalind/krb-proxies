# Copyright (C) 2013, Red Hat, Inc.
# All rights reserved.

# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:

#   Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.

#   Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.

#   Neither the name of Red Hat, Inc., nor the names of its
#   contributors may be used to endorse or promote products derived
#   from this software without specific prior written permission.

# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

import base64
import os
import socket
import struct
from pyasn1.type import univ, char, namedtype, tag
from pyasn1.codec.ber import encoder, decoder

class proxy_message_kerb_message(univ.OctetString):
  tagSet = univ.OctetString.tagSet.tagExplicitly(
    tag.Tag(tag.tagClassContext, tag.tagFormatConstructed, 0)
  )
class proxy_message_target_domain(char.GeneralString):
  tagSet = char.GeneralString.tagSet.tagExplicitly(
    tag.Tag(tag.tagClassContext, tag.tagFormatConstructed, 1)
  )
class proxy_message_dclocate_hint(univ.Integer):
  tagSet = univ.Integer.tagSet.tagExplicitly(
    tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 2)
  )
class proxy_message(univ.Sequence):
  componentType = namedtype.NamedTypes(
    namedtype.NamedType('message', proxy_message_kerb_message()),
    namedtype.OptionalNamedType('realm', proxy_message_target_domain()),
    namedtype.OptionalNamedType('flags', proxy_message_dclocate_hint())
  )
class as_req(univ.Sequence):
  tagSet = univ.Sequence.tagSet.tagExplicitly(
    tag.Tag(tag.tagClassApplication, tag.tagFormatSimple, 10)
  )
class tgs_req(univ.Sequence):
  tagSet = univ.Sequence.tagSet.tagExplicitly(
    tag.Tag(tag.tagClassApplication, tag.tagFormatSimple, 12)
  )
class ap_req(univ.Sequence):
  tagSet = univ.Sequence.tagSet.tagExplicitly(
    tag.Tag(tag.tagClassApplication, tag.tagFormatSimple, 14)
  )
class krb_priv(univ.Sequence):
  tagSet = univ.Sequence.tagSet.tagExplicitly(
    tag.Tag(tag.tagClassApplication, tag.tagFormatSimple, 21)
  )

def proxy(env, locate_kdc, locate_kpasswd, start_response):
  method = env["REQUEST_METHOD"].upper()
  if method != "POST":
    start_response("405 Method Not Allowed", [("Content-Type", "text/plain"),
                                              ("Allow", "POST")])
    return ["I don't know what that is!\r\nDumping env:\r\n%s\r\n" % str(env)]

  (req,err) = decoder.decode(env["wsgi.input"].read(), asn1Spec=proxy_message())
  if err != '':
    start_response("400 Bad Request", [("Content-Type", "text/plain")])
    return ["There was an error parsing the request.\r\n"]

  request = req.getComponentByName('message').asOctets()
  realm = req.getComponentByName('realm').asOctets()

  # Check the length of the whole request message.
  (length,) = struct.unpack("!I", request[0:4])
  if length + 4 != len(request):
    start_response("400 Bad Request", [("Content-Type", "text/plain")])
    return ["There was an error parsing the request length (1).\r\n"]
  try:
    # See if the tag looks like a TGS request.
    (kdcreq,err) = decoder.decode(request[4:], asn1Spec=tgs_req())
    # We shouldn't have any data left over.
    if len(err) > 0:
      start_response("400 Bad Request", [("Content-Type", "text/plain")])
      return ["The TGS request was followed by %d bytes of ???.\r\n" %
              len(err)]
    # Looks good.
    summary = "TGS-REQ (%d bytes)" % (len(request) - 4)
    serverAddr = locate_kdc(realm)
  except:
    try:
      # See if the tag looks like an AS request.
      (kdcreq,err) = decoder.decode(request[4:], asn1Spec=as_req())
      # We shouldn't have any data left over.
      if len(err) > 0:
        start_response("400 Bad Request", [("Content-Type", "text/plain")])
        return ["The AS request was followed by %d bytes of ???.\r\n" %
                len(err)]
      # Looks good.
      summary = "AS-REQ (%d bytes)" % (len(request) - 4)
      serverAddr = locate_kdc(realm)
    except:
      try:
        # Check the length count in the password change request, assuming it
        # actually is a password change request.  It should be the length of
        # the rest of the request, including itself.
        (length,) = struct.unpack("!H", request[4:6])
        if length != len(request) - 4:
          start_response("400 Bad Request", [("Content-Type", "text/plain")])
          return ["There was an error parsing the request length (2).\r\n"]
        # Check the version number in the password change request, assuming it
        # actually is a password change request.  Officially we support version
        # 1, but 0xff80 is used for set-password, so try to accept that, too.
        (version,) = struct.unpack("!H", request[6:8])
        if version != 0x0001 and version != 0xff80:
          start_response("400 Bad Request", [("Content-Type", "text/plain")])
          return ["The password change request(?) is an incorrect version.\r\n"]
        # Read the length of the AP-REQ part of the change request.  There
        # should be at least that may bytes following this length, since the
        # rest of the request is the KRB-PRIV message.
        (length,) = struct.unpack("!H", request[8:10])
        if length > len(request) - 10:
          start_response("400 Bad Request", [("Content-Type", "text/plain")])
          return ["The password change request(?) appears to be truncated.\r\n"]
        # See if the tag looks like an AP request, which would look like the
        # start of a password change request.
        (apreq,err) = decoder.decode(request[10:length + 10], asn1Spec=ap_req())
        # The rest of it should be a KRB-PRIV message.
        (krbpriv,err) = decoder.decode(request[length + 10:],
                                       asn1Spec=krb_priv())
        # We shouldn't have any data left over.
        if len(err) > 0:
          start_response("400 Bad Request", [("Content-Type", "text/plain")])
          return ["The password change request was followed by %d bytes of "
                  "???.\r\n" % len(err)]
        # Looks good.
        summary = "KPASSWD (version 0x%04x) (%d bytes)" % (version,
                                                           len(request) - 4)
        serverAddr = locate_kpasswd(realm)
      except:
        start_response("400 Bad Request", [("Content-Type", "text/plain")])
        return ["There was an error parsing the request.\r\n"]

  try:
    #print summary
    server = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)
    server.connect(serverAddr)
  except:
    try:
      server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
      server.connect(serverAddr)
    except:
      start_response("503 Unavailable", [("Content-Type", "text/plain")])
      raise "There was an error connecting to remote server for %s." % summary
      return ["There was an error connecting to the server for %s." % summary]

  server.sendall(request)
  reply = server.recv(1048576)
  server.close()

  rep = proxy_message()
  rep.setComponentByName('message',reply)
  encoded_rep = encoder.encode(rep)
  start_response("200 OK", [("Content-Type", "application/kerberos"),
                            ("Content-Length", str(len(encoded_rep)))])
  return [encoded_rep]


def application(env, start_response):
  kdcAddr = ("localhost", 88)
  kpasswdAddr = ("localhost", 464)
  return proxy(env,
               lambda realm: kdcAddr,
               lambda realm: kpasswdAddr,
               start_response)
